{"body":"<p>How can I determine whether a variable is a string or something else in JavaScript?</p>\n","title":"Check if a variable is a string in JavaScript","answers":[{"score":1872,"body":"<p>You can use <code>typeof</code> operator:</p>\n\n<pre><code>var booleanValue = true; \nvar numericalValue = 354;\nvar stringValue = \"This is a String\";\nvar stringObject = new String( \"This is a String Object\" );\nalert(typeof booleanValue) // displays \"boolean\"\nalert(typeof numericalValue) // displays \"number\"\nalert(typeof stringValue) // displays \"string\"\nalert(typeof stringObject) // displays \"object\"\n</code></pre>\n\n<p>Example from <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\" rel=\"noreferrer\">this webpage</a>. (Example was slightly modified though).</p>\n\n<p>This won't work as expected in the case of strings created with <code>new String()</code>, but this is seldom used and recommended against<sup>[1][2]</sup>. See the other answers for how to handle these, if you so desire.</p>\n\n<hr>\n\n<ol>\n<li>The Google JavaScript Style Guide <a href=\"https://google.github.io/styleguide/jsguide.html#disallowed-features-wrapper-objects\" rel=\"noreferrer\">says to never use primitive object wrappers</a>.</li>\n<li>Douglas Crockford <a href=\"http://www.crockford.com/javascript/recommend.html\" rel=\"noreferrer\">recommended that primitive object wrappers be deprecated</a>.</li>\n</ol>\n"},{"score":2050,"body":"<p>This is what works for me:</p>\n\n<pre><code>if (typeof myVar === 'string' || myVar instanceof String)\n// it's a string\nelse\n// it's something else\n</code></pre>\n"},{"score":32,"body":"<p>Best way:</p>\n<pre><code>var s = 'String';\nvar a = [1,2,3];\nvar o = {key: 'val'};\n\n(s.constructor === String) &amp;&amp; console.log('its a string');\n(a.constructor === Array) &amp;&amp; console.log('its an array');\n(o.constructor === Object) &amp;&amp; console.log('its an object');\n(o.constructor === Number || s.constructor === Boolean) &amp;&amp; console.log('this won\\'t run');\n</code></pre>\n<p>Each of these has been constructed by its appropriate class function, like &quot;new Object()&quot; etc.</p>\n<p>Also, Duck-Typing:\n&quot;If it looks like a duck, walks like a duck, and smells like a duck - it must be an Array&quot;\nMeaning, check its properties.</p>\n<p>Hope this helps.</p>\n<h3>Edit; 12/05/2016</h3>\n<p>Remember, you can always use combinations of approaches too. Here's an example of using an <em>inline map</em> of actions with <em>typeof</em>:</p>\n<pre><code>var type = { 'number': Math.sqrt.bind(Math), ... }[ typeof datum ];\n</code></pre>\n<p>Here's a more 'real world' example of using inline-maps:</p>\n<pre><code>function is(datum) {\n    var isnt = !{ null: true, undefined: true, '': true, false: false, 0: false }[ datum ];\n    return !isnt;\n}\nconsole.log( is(0), is(false), is(undefined), ... );  // &gt;&gt; true true false\n</code></pre>\n<p>This function would use [ custom ] &quot;type-casting&quot; -- rather, &quot;type-/-value-mapping&quot; -- to figure out if a variable actually &quot;exists&quot;. Now you can split that nasty hair between <code>null</code> &amp; <code>0</code>!</p>\n<p>Many times <em>you don't even care about its type</em>. Another way to circumvent typing is combining Duck-Type sets:</p>\n<pre><code>this.id = &quot;998&quot;;  // use a number or a string-equivalent\nfunction get(id) {\n    if (!id || !id.toString) return;\n    if (id.toString() === this.id.toString()) http( id || +this.id );\n    // if (+id === +this.id) ...;\n}\n</code></pre>\n<p>Both <code>Number.prototype</code> <strong>and</strong> <code>String.prototype</code> have a <code>.toString() method</code>. You just made sure that the string-equivalent of the number was the same, and then you made sure that you passed it into the <code>http</code> function as a <code>Number</code>. In other words, we didn't even <em>care</em> what its type was.</p>\n<p>Hope that gives you more to work with :)</p>\n"},{"score":180,"body":"<p>Since 580+ people have voted for an incorrect answer, and 800+ have voted for a working but shotgun-style answer, I thought it might be worth redoing my answer in a simpler form that everybody can understand.</p>\n\n<pre><code>function isString(x) {\n  return Object.prototype.toString.call(x) === \"[object String]\"\n}\n</code></pre>\n\n<p>Or, inline (I have an UltiSnip setup for this):</p>\n\n<pre><code>Object.prototype.toString.call(myVar) === \"[object String]\"\n</code></pre>\n\n<p>FYI, Pablo Santa Cruz's answer is wrong, because <code>typeof new String(\"string\")</code> is <code>object</code></p>\n\n<p>DRAX's answer is accurate and functional, and should be the correct answer (since Pablo Santa Cruz is most definitely incorrect, and I won't argue against the popular vote.)</p>\n\n<p>However, this answer is also definitely correct, and actually the best answer (except, perhaps, for the suggestion of using <a href=\"https://lodash.com/\" rel=\"noreferrer\">lodash</a>/<a href=\"http://underscorejs.org/\" rel=\"noreferrer\">underscore</a>). <em>disclaimer: I contributed to the lodash 4 codebase.</em></p>\n\n<p>My original answer (which obviously flew right over a lot of heads) follows: </p>\n\n<p>I transcoded this from underscore.js:</p>\n\n<pre><code>['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'].forEach( \n    function(name) { \n        window['is' + name] = function(obj) {\n              return toString.call(obj) == '[object ' + name + ']';\n    }; \n});\n</code></pre>\n\n<p>That will define isString, isNumber, etc.</p>\n\n<hr>\n\n<p>In Node.js, this can be implemented as a module:</p>\n\n<pre><code>module.exports = [\n  'Arguments',\n  'Function', \n  'String', \n  'Number', \n  'Date', \n  'RegExp'\n].reduce( (obj, name) =&gt; {\n  obj[ 'is' + name ] = x =&gt; toString.call(x) == '[object ' + name + ']';\n  return obj;\n}, {});\n</code></pre>\n\n<p>[edit]: <code>Object.prototype.toString.call(x)</code> works to delineate between functions and async functions as well:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const fn1 = () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve({}), 1000))\r\nconst fn2 = async () =&gt; ({})\r\n\r\nconsole.log('fn1', Object.prototype.toString.call(fn1))\r\nconsole.log('fn2', Object.prototype.toString.call(fn2))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":6,"body":"<p>I also found that this works fine too, and its a lot shorter than the other examples.</p>\n\n<pre><code>if (myVar === myVar + '') {\n   //its string\n} else {\n   //its something else\n}\n</code></pre>\n\n<p>By concatenating on empty quotes it turns the value into a string. If <code>myVar</code> is already a string then the if statement is successful.</p>\n"},{"score":84,"body":"<p>I recommend using the built-in functions from <strong>jQuery</strong> or <strong>lodash/Underscore</strong>.  They're simpler to use and easier to read.</p>\n\n<p>Either function will handle the case DRAX mentioned...  that is, they <em>both</em> check if (A) the variable is a string literal or (B) it's an instance of the String object.  In either case, these functions correctly identify the value as being a string.</p>\n\n<p><strong>lodash / Underscore.js</strong></p>\n\n<pre><code>if(_.isString(myVar))\n   //it's a string\nelse\n   //it's something else\n</code></pre>\n\n<p><strong>jQuery</strong></p>\n\n<pre><code>if($.type(myVar) === \"string\")\n   //it's a string\nelse\n   //it's something else\n</code></pre>\n\n<p>See <a href=\"https://lodash.com/docs#isString\">lodash Documentation for _.isString()</a> for more details.</p>\n\n<p>See <a href=\"http://api.jquery.com/jQuery.type/\">jQuery Documentation for $.type()</a> for more details.</p>\n"},{"score":36,"body":"<pre><code>function isString (obj) {\n  return (Object.prototype.toString.call(obj) === '[object String]');\n}\n</code></pre>\n\n<p>I saw that here:</p>\n\n<p><a href=\"http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\">http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/</a></p>\n"},{"score":1,"body":"<p>Just to expand on @DRAX's <a href=\"https://stackoverflow.com/a/9436948/670017\">answer</a>, I'd do this:</p>\n\n<pre><code>function isWhitespaceEmptyString(str)\n{\n    //RETURN:\n    //      = 'true' if 'str' is empty string, null, undefined, or consists of white-spaces only\n    return str ? !(/\\S/.test(str)) : (str === \"\" || str === null || str === undefined);\n}\n</code></pre>\n\n<p>It will account also for <code>null</code>s and <code>undefined</code> types, and it will take care of non-string types, such as <code>0</code>.</p>\n"},{"score":3,"body":"<p>A simple solution would be:</p>\n\n<pre><code>var x = \"hello\"\n\nif(x === x.toString()){\n// it's a string \n}else{\n// it isn't\n}\n</code></pre>\n"},{"score":8,"body":"<p>Taken from lodash:</p>\n\n<pre><code>function isString(val) {\n   return typeof val === 'string' || ((!!val &amp;&amp; typeof val === 'object') &amp;&amp; Object.prototype.toString.call(val) === '[object String]');\n}\n\nconsole.log(isString('hello world!')); // true\nconsole.log(isString(new String('hello world'))); // true\n</code></pre>\n"},{"score":3,"body":"<pre><code>var a = new String('')\nvar b = ''\nvar c = []\n\nfunction isString(x) {\n  return x !== null &amp;&amp; x !== undefined &amp;&amp; x.constructor === String\n}\n\nconsole.log(isString(a))\nconsole.log(isString(b))\nconsole.log(isString(c))\n</code></pre>\n"},{"score":5,"body":"<p>If you work on the node.js environment, you can simply use the built-in function isString in utils.</p>\n\n<pre><code>const util = require('util');\nif (util.isString(myVar)) {}\n</code></pre>\n\n<p>Edit: as @Jehy mentioned, this is deprecated since v4.</p>\n"},{"score":-2,"body":"<p>I'm not sure if you mean knowing if it's a type <code>string</code> regardless of its contents, or whether it's contents is a number or string, regardless of its type.<br><br>\nSo to know if its type is a string, that's already been answered.\n<br>\nBut to know based on its contents if its a string or a number, I would use this:</p>\n\n<pre><code>function isNumber(item) {\n    return (parseInt(item) + '') === item;\n}\n</code></pre>\n\n<p>And for some examples:</p>\n\n<pre><code>isNumber(123);   //true\nisNumber('123'); //true\nisNumber('123a');//false\nisNumber('');    //false\n</code></pre>\n"},{"score":16,"body":"<p>I like to use this simple solution:</p>\n\n<pre><code>var myString = \"test\";\nif(myString.constructor === String)\n{\n     //It's a string\n}\n</code></pre>\n"},{"score":16,"body":"<p>This is a great example of why performance matters:</p>\n\n<p>Doing something as simple as a test for a string can be expensive if not done correctly.</p>\n\n<p>For example, if I wanted to write a function to test if something is a string, I could do it in one of two ways:</p>\n\n<p>1) <code>const isString = str =&gt; (Object.prototype.toString.call(str) === '[object String]');</code></p>\n\n<p>2) <code>const isString = str =&gt; ((typeof str === 'string') || (str instanceof String));</code></p>\n\n<p>Both of these are pretty straight forward, so what could possibly impact performance?  Generally speaking, function calls can be expensive, especially if you don't know what's happening inside. In the first example, there is a function call to Object's toString method.  In the second example, there are no function calls, as typeof and instanceof are operators. Operators are significantly faster than function calls.</p>\n\n<p>When the performance is tested, example 1 is 79% slower than example 2!</p>\n\n<p>See the tests: <a href=\"https://jsperf.com/isstringtype\" rel=\"noreferrer\">https://jsperf.com/isstringtype</a></p>\n"},{"score":4,"body":"<p>The following method will check if any variable is a string (<strong>including variables that do not exist</strong>).</p>\n\n<pre><code>const is_string = value =&gt; {\n  try {\n    return typeof value() === 'string';\n  } catch (error) {\n    return false;\n  }\n};\n\nlet example = 'Hello, world!';\n\nconsole.log(is_string(() =&gt; example)); // true\nconsole.log(is_string(() =&gt; variable_doesnt_exist)); // false\n</code></pre>\n"},{"score":2,"body":"<p>This is good enough for me.</p>\n\n<p><strong>WARNING:</strong> This is not a perfect solution.\nSee the bottom of my post.</p>\n\n<pre><code>Object.prototype.isString = function() { return false; };\nString.prototype.isString = function() { return true; };\n\nvar isString = function(a) {\n  return (a !== null) &amp;&amp; (a !== undefined) &amp;&amp; a.isString();\n};\n</code></pre>\n\n<p>And you can use this like below.</p>\n\n<pre><code>//return false\nisString(null);\nisString(void 0);\nisString(-123);\nisString(0);\nisString(true);\nisString(false);\nisString([]);\nisString({});\nisString(function() {});\nisString(0/0);\n\n//return true\nisString(\"\");\nisString(new String(\"ABC\"));\n</code></pre>\n\n<p><strong>WARNING:</strong> This works incorrectly in the case:</p>\n\n<pre><code>//this is not a string\nvar obj = {\n    //but returns true lol\n    isString: function(){ return true; }\n}\n\nisString(obj) //should be false, but true\n</code></pre>\n"},{"score":22,"body":"<p>I can't honestly see why one would not simply use <code>typeof</code> in this case:</p>\n\n<pre><code>if (typeof str === 'string') {\n  return 42;\n}\n</code></pre>\n\n<p>Yes it will fail against object-wrapped strings (e.g. <code>new String('foo')</code>) but these are widely regarded as a bad practice and most modern development tools are likely to discourage their use. <em>(If you see one, just fix it!)</em></p>\n\n<p>The <code>Object.prototype.toString</code> trick is something that all front-end developers have been found guilty of doing one day in their careers but don't let it fool you by its polish of clever: it will break as soon as something monkey-patch the Object prototype:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const isString = thing =&gt; Object.prototype.toString.call(thing) === '[object String]';\r\n\r\nconsole.log(isString('foo'));\r\n\r\nObject.prototype.toString = () =&gt; 42;\r\n\r\nconsole.log(isString('foo'));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2,"body":"<p>You can use this function to determine the type of anything:</p>\n<pre><code>var type = function(obj) {\n    return Object.prototype.toString.apply(obj).replace(/\\[object (.+)\\]/i, '$1').toLowerCase();\n};\n</code></pre>\n<p>To check if a variable is a string:</p>\n<pre><code>type('my string') === 'string' //true\ntype(new String('my string')) === 'string' //true\ntype(`my string`) === 'string' //true\ntype(12345) === 'string' //false\ntype({}) === 'string' // false\n</code></pre>\n<p><a href=\"https://codepen.io/patodiblasi/pen/NQXPwY?editors=0012\" rel=\"nofollow noreferrer\">https://codepen.io/patodiblasi/pen/NQXPwY?editors=0012</a></p>\n<p>To check for other types:</p>\n<pre><code>type(null) //null\ntype(undefined) //undefined\ntype([]) //array\ntype({}) //object\ntype(function() {}) //function\ntype(123) //number\ntype(new Number(123)) //number\ntype(/some_regex/) //regexp\ntype(Symbol(&quot;foo&quot;)) //symbol\n</code></pre>\n"},{"score":7,"body":"<p>I think that @customcommander solution should suffice in 90% of your cases:</p>\n\n<pre><code>typeof str === 'string'\n</code></pre>\n\n<p>Should serve you right (simply since normally there's no reason to have <code>new String('something')</code> in your code).</p>\n\n<p>If you're interested in handling the <code>String</code> object as well (for example you expect some var from a 3rd party) then using lodash as @ClearCloud8 suggested seems like a clear, simple and elegant solution.</p>\n\n<p>I would however suggest to be cautious with libraries such as lodash due to their size. Instead of doing</p>\n\n<pre><code>import _ from 'lodash'\n...\n_.isString(myVar)\n</code></pre>\n\n<p>Which brings the whole huge lodash object, I'd suggest something like:</p>\n\n<pre><code>import { isString as _isString } from 'lodash'\n...\n_isString(myVar)\n</code></pre>\n\n<p>And with simple bundling you should be fine (I refer here to client code).</p>\n"},{"score":4,"body":"<p>I find this simple technique useful to type-check for <strong>String</strong> -</p>\n\n<pre><code>String(x) === x // true, if x is a string\n                // false in every other case\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const test = x =&gt;\r\n  console.assert\r\n    ( String(x) === x\r\n    , `not a string: ${x}`\r\n    )\r\n\r\ntest(\"some string\")\r\ntest(123)           // assertion failed\r\ntest(0)             // assertion failed\r\ntest(/some regex/)  // assertion failed\r\ntest([ 5, 6 ])      // assertion failed\r\ntest({ a: 1 })      // assertion failed\r\ntest(x =&gt; x + 1)    // assertion failed</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The same technique works for <strong>Number</strong> too -</p>\n\n<pre><code>Number(x) === x // true, if x is a number\n                // false in every other case\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const test = x =&gt;\r\n  console.assert\r\n    ( Number(x) === x\r\n    , `not a number: ${x}`\r\n    )\r\n\r\ntest(\"some string\") // assertion failed\r\ntest(123)           \r\ntest(0)             \r\ntest(/some regex/)  // assertion failed\r\ntest([ 5, 6 ])      // assertion failed\r\ntest({ a: 1 })      // assertion failed\r\ntest(x =&gt; x + 1)    // assertion failed</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>And for <strong>RegExp</strong> -</p>\n\n<pre><code>RegExp(x) === x // true, if x is a regexp\n                // false in every other case\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const test = x =&gt;\r\n  console.assert\r\n    ( RegExp(x) === x\r\n    , `not a regexp: ${x}`\r\n    )\r\n\r\ntest(\"some string\") // assertion failed\r\ntest(123)           // assertion failed\r\ntest(0)             // assertion failed\r\ntest(/some regex/)  \r\ntest([ 5, 6 ])      // assertion failed\r\ntest({ a: 1 })      // assertion failed\r\ntest(x =&gt; x + 1)    // assertion failed</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Same for <strong>Object</strong> -</p>\n\n<pre><code>Object(x) === x // true, if x is an object\n                // false in every other case\n</code></pre>\n\n<p>NB, regexps, arrays, and functions are considered objects too.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const test = x =&gt;\r\n  console.assert\r\n    ( Object(x) === x\r\n    , `not an object: ${x}`\r\n    )\r\n\r\ntest(\"some string\") // assertion failed\r\ntest(123)           // assertion failed\r\ntest(0)             // assertion failed\r\ntest(/some regex/)  \r\ntest([ 5, 6 ])      \r\ntest({ a: 1 })      \r\ntest(x =&gt; x + 1)    </code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>But, checking for <strong>Array</strong> is a bit different -</p>\n\n<pre><code>Array.isArray(x) === x // true, if x is an array\n                       // false in every other case\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const test = x =&gt;\r\n  console.assert\r\n    ( Array.isArray(x)\r\n    , `not an array: ${x}`\r\n    )\r\n\r\ntest(\"some string\") // assertion failed\r\ntest(123)           // assertion failed\r\ntest(0)             // assertion failed\r\ntest(/some regex/)  // assertion failed\r\ntest([ 5, 6 ])      \r\ntest({ a: 1 })      // assertion failed\r\ntest(x =&gt; x + 1)    // assertion failed</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This technique does <em>not</em> work for <strong>Functions</strong> however -</p>\n\n<pre><code>Function(x) === x // always false\n</code></pre>\n"},{"score":2,"body":"<p>A Typechecker helper:</p>\n\n<pre><code>function isFromType(variable, type){\n  if (typeof type == 'string') res = (typeof variable == type.toLowerCase())\n  else res = (variable.constructor == type)\n  return res\n}\n</code></pre>\n\n<p>usage:</p>\n\n<pre><code>isFromType('cs', 'string') //true\nisFromType('cs', String) //true\nisFromType(['cs'], Array) //true\nisFromType(['cs'], 'object') //false\n</code></pre>\n\n<p>Also if you want it to be recursive(like Array that is an Object), you can use <code>instanceof</code>.</p>\n\n<p>(<code>['cs'] instanceof Object //true</code>)</p>\n"},{"score":15,"body":"<pre><code>if (s &amp;&amp; typeof s.valueOf() === \"string\") {\n  // s is a string\n}\n</code></pre>\n\n<p>Works for both string literals <code>let s = 'blah'</code> and for Object Strings <code>let s = new String('blah')</code></p>\n"},{"score":3,"body":"<p>I'm going to go a different route to the rest here, which try to tell if a variable is a specific, or a member of a specific set, of types.<br>\nJS is built on ducktyping; if something quacks like a string, we can and should use it like a string.</p>\n\n<p>Is <code>7</code> a string? Then why does <code>/\\d/.test(7)</code> work?<br>\nIs <code>{toString:()=&gt;('hello there')}</code> a string? Then why does <code>({toString:()=&gt;('hello there')}) + '\\ngeneral kenobi!'</code> work?<br>\nThese aren't questions about <em>should</em> the above work, the point is they do.</p>\n\n<p>So I made a <a href=\"https://jsfiddle.net/o1sxzemg/\" rel=\"nofollow noreferrer\"><code>duckyString()</code> function</a><br>\nBelow I test many cases not catered for by other answers. For each the code:</p>\n\n<ul>\n<li>sets a string-like variable</li>\n<li>runs an identical string operation on it and a real string to compare outputs (proving they can be treated like strings)</li>\n<li>converts the string-like to a real string to show you <code>duckyString()</code> to normalise inputs for code that expects real strings</li>\n</ul>\n\n\n\n<pre class=\"lang-js prettyprint-override\"><code>text = 'hello there';\nout(text.replace(/e/g, 'E') + ' ' + 'hello there'.replace(/e/g, 'E'));\nout('Is string? ' + duckyString(text) + '\\t\"' + duckyString(text, true) + '\"\\n');\n\ntext = new String('oh my');\nout(text.toUpperCase() + ' ' + 'oh my'.toUpperCase());\nout('Is string? ' + duckyString(text) + '\\t\"' + duckyString(text, true) + '\"\\n');\n\ntext = 368;\nout((text + ' is a big number') + ' ' + ('368' + ' is a big number'));\nout('Is string? ' + duckyString(text) + '\\t\"' + duckyString(text, true) + '\"\\n');\n\ntext = ['\\uD83D', '\\uDE07'];\nout(text[1].charCodeAt(0) + ' ' + 'ðŸ˜‡'[1].charCodeAt(0));\nout('Is string? ' + duckyString(text) + '\\t\"' + duckyString(text, true) + '\"\\n');\n\nfunction Text() { this.math = 7; }; Text.prototype = {toString:function() { return this.math + 3 + ''; }}\ntext = new Text();\nout(String.prototype.match.call(text, '0') + ' ' + text.toString().match('0'));\nout('Is string? ' + duckyString(text) + '\\t\"' + duckyString(text, true) + '\"\\n');\n</code></pre>\n\n<p>This is in the same vein as <code>!!x</code> as opposed to <code>x===true</code> and testing if something is array-<em>like</em> instead of necessitating an actual array.<br>\njQuery objects; are they arrays? No. Are they good enough? Yeah, you can run them through <code>Array.prototype</code> functions just fine.<br>\nIt's this flexibility that gives JS its power, and testing <em>for</em> strings specifically makes your code less interoperable.</p>\n\n<p>The output of the above is:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>hEllo thErE hEllo thErE\nIs string? true \"hello there\"\n\nOH MY OH MY\nIs string? true \"oh my\"\n\n368 is a big number 368 is a big number\nIs string? true \"368\"\n\n56839 56839\nIs string? true \"ðŸ˜‡\"\n\n0 0\nIs string? true \"10\"\n</code></pre>\n\n<p>So, it's all about <em>why</em> you want to know if something's a string.<br>\nIf, like me, you arrived here from google and wanted to see if something was <em>string-like</em>, here's an answer.<br>\nIt isn't even expensive unless you're working with really long or deeply nested char arrays.<br>\nThis is because it is all if statements, no function calls like <code>.toString()</code>.<br>\n<sub>Except if you're trying to see if a char array with objects that only have <code>toString()</code>'s or multi-byte characters, in which case there's no other way to check except to make the string, and count characters the bytes make up, respectively</sub></p>\n\n<pre class=\"lang-js prettyprint-override\"><code>function duckyString(string, normalise, unacceptable) {\n    var type = null;\n    if (!unacceptable)\n        unacceptable = {};\n    if (string &amp;&amp; !unacceptable.chars &amp;&amp; unacceptable.to == null)\n        unacceptable.to = string.toString == Array.prototype.toString;\n\n    if (string == null)\n        ;\n\n    //tests if `string` just is a string\n    else if (\n        !unacceptable.is &amp;&amp;\n        (typeof string == 'string' || string instanceof String)\n    )\n        type = 'is';\n\n    //tests if `string + ''` or `/./.test(string)` is valid\n    else if (\n        !unacceptable.to &amp;&amp;\n        string.toString &amp;&amp; typeof string.toString == 'function' &amp;&amp; string.toString != Object.prototype.toString\n    )\n        type = 'to';\n\n    //tests if `[...string]` is valid\n    else if (\n        !unacceptable.chars &amp;&amp;\n        (string.length &gt; 0 || string.length == 0)\n    ) {\n        type = 'chars';\n        //for each char\n        for (var index = 0; type &amp;&amp; index &lt; string.length; ++index) {\n            var char = string[index];\n\n            //efficiently get its length\n            var length = ((duckyString(char, false, {to:true})) ?\n                char :\n                duckyString(char, true) || {}\n            ).length;\n\n            if (length == 1)\n                continue;\n\n            //unicode surrogate-pair support\n            char = duckyString(char, true);\n            length = String.prototype[Symbol &amp;&amp; Symbol.iterator];\n            if (!(length = length &amp;&amp; length.call(char)) || length.next().done || !length.next().done)\n                type = null;\n        }\n    }\n\n    //return true or false if they dont want to auto-convert to real string\n    if (!(type &amp;&amp; normalise))\n        //return truthy or falsy with &lt;type&gt;/null if they want why it's true\n        return (normalise == null) ? type != null : type;\n\n    //perform conversion\n    switch (type) {\n    case 'is':\n        return string;\n    case 'to':\n        return string.toString();\n    case 'chars':\n        return Array.from(string).join('');\n    }\n}\n</code></pre>\n\n<p>Included are options to</p>\n\n<ul>\n<li>ask which method deemed it string-y</li>\n<li>exclude methods of string-detection (eg if you dont like <code>.toString()</code>)</li>\n</ul>\n\n<p>Here are more tests because I'm a completionist:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>out('Edge-case testing')\nfunction test(text, options) {\n    var result = duckyString(text, false, options);\n    text = duckyString(text, true, options);\n    out(result + ' ' + ((result) ? '\"' + text + '\"' : text));\n}\ntest('');\ntest(null);\ntest(undefined);\ntest(0);\ntest({length:0});\ntest({'0':'!', length:'1'});\ntest({});\ntest(window);\ntest(false);\ntest(['hi']);\ntest(['\\uD83D\\uDE07']);\ntest([['1'], 2, new String(3)]);\ntest([['1'], 2, new String(3)], {chars:true});\n</code></pre>\n\n<ul>\n<li>All negative cases seem to be accounted for</li>\n<li>This should run on browsers >= IE8</li>\n<li>Char arrays with multiple bytes supported on browsers with string iterator support</li>\n</ul>\n\n<p>Output:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>Edge-case testing\nis \"\"\nnull null\nnull null\nto \"0\"\nchars \"\"\nchars \"!\"\nnull null\nchars \"\"\nto \"false\"\nnull null\nchars \"ðŸ˜‡\"\nchars \"123\"\nto \"1,2,3\"\n</code></pre>\n"},{"score":7,"body":"<h1>Performance</h1>\n<p>Today 2020.09.17 I perform tests on MacOs HighSierra 10.13.6 on Chrome v85, Safari v13.1.2 and Firefox v80 for chosen solutions.</p>\n<h2>Results</h2>\n<p>For all browsers (and both test cases)</p>\n<ul>\n<li>solutions <code>typeof||instanceof</code> (A, I) and <code>x===x+''</code> (H) are fast/fastest</li>\n<li>solution <code>_.isString</code> (lodash lib) is medium/fast</li>\n<li>solutions B and K are slowest</li>\n</ul>\n<p><a href=\"https://i.stack.imgur.com/cpaxI.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/cpaxI.png\" alt=\"enter image description here\" /></a></p>\n<p>Update: 2020.11.28 I update results for <code>x=123 Chrome</code> column - for solution <code>I</code> there was probably an error value before (=69M too low) - I use Chrome 86.0 to repeat tests.</p>\n<h2>Details</h2>\n<p>I perform 2 tests cases for solutions\n<a href=\"https://stackoverflow.com/a/9436948/860099\">A</a>\n<a href=\"https://stackoverflow.com/a/17772086/860099\">B</a>\n<a href=\"https://stackoverflow.com/a/20958909/860099\">C</a>\n<a href=\"https://stackoverflow.com/a/20958909/860099\">D</a>\n<a href=\"https://stackoverflow.com/a/16215800/860099\">E</a>\n<a href=\"https://stackoverflow.com/a/42493631/860099\">F</a>\n<a href=\"https://stackoverflow.com/a/57443488/860099\">G</a>\n<a href=\"https://stackoverflow.com/a/19057360/860099\">H</a>\n<a href=\"https://stackoverflow.com/a/4059166/860099\">I</a>\n<a href=\"https://stackoverflow.com/a/28722301/860099\">J</a>\n<a href=\"https://stackoverflow.com/a/58892465/860099\">K</a>\n<a href=\"https://stackoverflow.com/a/9436948/860099\">L</a></p>\n<ul>\n<li>when variable is string - you can run it <a href=\"https://jsbench.me/whkf5hbrps/1\" rel=\"nofollow noreferrer\">HERE</a></li>\n<li>when variable is NOT string - you can run it <a href=\"https://jsbench.me/p0kf5vcq3c/1\" rel=\"nofollow noreferrer\">HERE</a></li>\n</ul>\n<p>Below snippet presents differences between solutions</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// https://stackoverflow.com/a/9436948/860099\nfunction A(x) {\n  return (typeof x == 'string') || (x instanceof String)\n}\n\n// https://stackoverflow.com/a/17772086/860099\nfunction B(x) {\n  return Object.prototype.toString.call(x) === \"[object String]\"\n}\n\n// https://stackoverflow.com/a/20958909/860099\nfunction C(x) {\n  return _.isString(x);\n}\n\n// https://stackoverflow.com/a/20958909/860099\nfunction D(x) {\n  return $.type(x) === \"string\";\n}\n\n// https://stackoverflow.com/a/16215800/860099\nfunction E(x) {\n  return x?.constructor === String;\n}\n\n// https://stackoverflow.com/a/42493631/860099\nfunction F(x){\n  return x?.charAt != null\n}\n\n\n// https://stackoverflow.com/a/57443488/860099\nfunction G(x){\n  return String(x) === x\n}\n\n// https://stackoverflow.com/a/19057360/860099\nfunction H(x){\n  return x === x + ''\n}\n\n// https://stackoverflow.com/a/4059166/860099\nfunction I(x) {\n  return typeof x == 'string'\n}\n\n// https://stackoverflow.com/a/28722301/860099\nfunction J(x){\n  return x === x?.toString()\n}\n\n// https://stackoverflow.com/a/58892465/860099\nfunction K(x){\n  return x &amp;&amp; typeof x.valueOf() === \"string\"\n}\n\n// https://stackoverflow.com/a/9436948/860099\nfunction L(x) {\n  return x instanceof String\n}\n\n// ------------------\n//     PRESENTATION\n// ------------------\n\nconsole.log('Solutions results for different inputs \\n\\n');\nconsole.log(\"'abc' Str  ''  ' ' '1' '0'  1   0   {} [] true false null undef\");\n\nlet tests = [ 'abc', new String(\"abc\"),'',' ','1','0',1,0,{},[],true,false,null,undefined];\n\n[A,B,C,D,E,F,G,H,I,J,K,L].map(f=&gt; {  \nconsole.log(\n  `${f.name}   ` + tests.map(v=&gt; (1*!!f(v)) ).join`   `\n)})</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\" integrity=\"sha512-90vH1Z83AJY9DmlWa8WkjkV79yfS2n2Oxhsi2dZbIv0nC4E6m5AbH8Nh156kkM7JePmqD6tcZsfad1ueoaovww==\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n\n\nThis shippet only presents functions used in performance tests - it not perform tests itself!</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>And here are example results for chrome</p>\n<p><a href=\"https://i.stack.imgur.com/oCOIh.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/oCOIh.png\" alt=\"enter image description here\" /></a></p>\n"}],"score":1916}