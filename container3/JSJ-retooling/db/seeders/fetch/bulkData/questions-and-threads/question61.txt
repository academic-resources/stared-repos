{"body":"<blockquote>\n  <p><strong>Moderator note:</strong> Please resist the urge to edit the code or remove this notice. The pattern of whitespace may be part of the question and therefore should not be tampered with unnecessarily. If you are in the \"whitespace is insignificant\" camp, you should be able to accept the code as is.</p>\n</blockquote>\n\n<p>Is it ever possible that <code>(a== 1 &amp;&amp; a ==2 &amp;&amp; a==3)</code> could evaluate to <code>true</code> in JavaScript?</p>\n\n<p>This is an interview question asked by a major tech company. It happened two weeks back, but I'm still trying to find the answer. I know we never write such code in our day-to-day job, but I'm curious.</p>\n","title":"Can (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) ever evaluate to true?","answers":[{"score":627,"body":"<p>IT IS POSSIBLE!</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var i = 0;\r\n\r\nwith({\r\n  get a() {\r\n    return ++i;\r\n  }\r\n}) {\r\n  if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)\r\n    console.log(\"wohoo\");\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This uses a getter inside of a <code>with</code> statement to let <code>a</code> evaluate to three different values.</p>\n\n<p>... this still does not mean this should be used in real code...</p>\n\n<p>Even worse, this trick will also work with the use of <code>===</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>  var i = 0;\r\n\r\n  with({\r\n    get a() {\r\n      return ++i;\r\n    }\r\n  }) {\r\n    if (a !== a)\r\n      console.log(\"yep, this is printed.\");\r\n  }</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3367,"body":"<p>If you take advantage of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\" rel=\"noreferrer\">how <code>==</code> works</a>, you could simply create an object with a custom <code>toString</code> (or <code>valueOf</code>) function that changes what it returns each time it is used such that it satisfies all three conditions.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const a = {\r\n  i: 1,\r\n  toString: function () {\r\n    return a.i++;\r\n  }\r\n}\r\n\r\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('Hello World!');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<hr>\n\n<p>The reason this works is due to the use of the loose equality operator. When using loose equality, if one of the operands is of a different type than the other, the engine will attempt to convert one to the other. In the case of an object on the left and a number on the right, it will attempt to convert the object to a number by first calling <code>valueOf</code> if it is callable, and failing that, it will call <code>toString</code>. I used <code>toString</code> in this case simply because it's what came to mind, <code>valueOf</code> would make more sense. If I instead returned a string from <code>toString</code>, the engine would have then attempted to convert the string to a number giving us the same end result, though with a slightly longer path.</p>\n"},{"score":192,"body":"<p>It can be accomplished using the following in the global scope. For <code>nodejs</code> use <code>global</code> instead of <code>window</code> in the code below.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var val = 0;\r\nObject.defineProperty(window, 'a', {\r\n  get: function() {\r\n    return ++val;\r\n  }\r\n});\r\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('yay');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This answer abuses the implicit variables provided by the global scope in the execution context by defining a getter to retrieve the variable.</p>\n"},{"score":2075,"body":"<p>I couldn't resist - the other answers are undoubtedly true, but you really can't walk past the following code:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var aÔæ† = 1;\r\nvar a = 2;\r\nvar Ôæ†a = 3;\r\nif(aÔæ†==1 &amp;&amp; a== 2 &amp;&amp;Ôæ†a==3) {\r\n    console.log(\"Why hello there!\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Note the weird spacing in the <code>if</code> statement (that I copied from your question). It is the half-width Hangul (that's Korean for those not familiar) which is an Unicode space character that is not interpreted by ECMA script as a space character - this means that it is a valid character for an identifier. Therefore there are three completely different variables, one with the Hangul after the a, one with it before and the last one with just a. Replacing the space with <code>_</code> for readability, the same code would look like this:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a_ = 1;\r\nvar a = 2;\r\nvar _a = 3;\r\nif(a_==1 &amp;&amp; a== 2 &amp;&amp;_a==3) {\r\n    console.log(\"Why hello there!\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Check out <a href=\"https://mothereff.in/js-variables#%EF%BE%A0%E1%85%A0%E1%85%9F\" rel=\"noreferrer\">the validation on Mathias' variable name validator</a>. If that weird spacing was actually included in their question, I feel sure that it's a hint for this kind of answer.</p>\n\n<p>Don't do this. Seriously.</p>\n\n<p>Edit: It has come to my attention that (although not allowed to start a variable) the <a href=\"https://en.wikipedia.org/wiki/Zero-width_joiner\" rel=\"noreferrer\">Zero-width joiner</a> and <a href=\"https://en.wikipedia.org/wiki/Zero-width_non-joiner\" rel=\"noreferrer\">Zero-width non-joiner</a> characters are also permitted in variable names - see <a href=\"https://reverseengineering.stackexchange.com/q/53\">Obfuscating JavaScript with zero-width characters - pros and cons?</a>.</p>\n\n<p>This would look like the following:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a= 1;\r\nvar a‚Äç= 2; //one zero-width character\r\nvar a‚Äç‚Äç= 3; //two zero-width characters (or you can use the other one)\r\nif(a==1&amp;&amp;a‚Äç==2&amp;&amp;a‚Äç‚Äç==3) {\r\n    console.log(\"Why hello there!\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":267,"body":"<p>If it is asked if it is possible (not MUST), it can ask \"a\" to return a random number. It would be true if it generates 1, 2, and 3 sequentially.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>with({\r\n  get a() {\r\n    return Math.floor(Math.random()*4);\r\n  }\r\n}){\r\n  for(var i=0;i&lt;1000;i++){\r\n    if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){\r\n      console.log(\"after \" + (i+1) + \" trials, it becomes true finally!!!\");\r\n      break;\r\n    }\r\n  }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":148,"body":"<p>This is also possible using a series of self-overwriting getters:</p>\n\n<p>(This is similar to jontro's solution, but doesn't require a counter variable.)</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>(() =&gt; {\r\n    \"use strict\";\r\n    Object.defineProperty(this, \"a\", {\r\n        \"get\": () =&gt; {\r\n            Object.defineProperty(this, \"a\", {\r\n                \"get\": () =&gt; {\r\n                    Object.defineProperty(this, \"a\", {\r\n                        \"get\": () =&gt; {\r\n                            return 3;\r\n                        }\r\n                    });\r\n                    return 2;\r\n                },\r\n                configurable: true\r\n            });\r\n            return 1;\r\n        },\r\n        configurable: true\r\n    });\r\n    if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n        document.body.append(\"Yes, it‚Äôs possible.\");\r\n    }\r\n})();</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":131,"body":"<p>Alternatively, you could use a class for it and an instance for the check.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function A() {\r\n    var value = 0;\r\n    this.valueOf = function () { return ++value; };\r\n}\r\n\r\nvar a = new A;\r\n\r\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n    console.log('bingo!');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>Using ES6 classes it would look like this</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>class A {\r\n  constructor() {\r\n    this.value = 0;\r\n    this.valueOf();\r\n  }\r\n  valueOf() {\r\n    return this.value++;\r\n  };\r\n}\r\n\r\nlet a = new A;\r\n\r\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('bingo!');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":75,"body":"<p>Rule number one of interviews; never say impossible.</p>\n\n<p>No need for hidden character trickery.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>window.__defineGetter__( 'a', function(){\r\n    if( typeof i !== 'number' ){\r\n        // define i in the global namespace so that it's not lost after this function runs\r\n        i = 0;\r\n    }\r\n    return ++i;\r\n});\r\n\r\nif( a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 ){\r\n    alert( 'Oh dear, what have we done?' );\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":130,"body":"<p>I don't see this answer already posted, so I'll throw this one into the mix too. This is similar to <a href=\"https://stackoverflow.com/a/48274520/3357935\">Jeff's answer</a> with the half-width Hangul space.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a = 1;\r\nvar ÔΩÅ = 2;\r\nvar –∞ = 3;\r\nif(a == 1 &amp;&amp; ÔΩÅ == 2 &amp;&amp; –∞ == 3) {\r\n    console.log(\"Why hello there!\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>You might notice a slight discrepancy with the second one, but the first and third are identical to the naked eye. All 3 are distinct characters:</p>\n\n<p><code>a</code> - Latin lower case A<br>\n<code>ÔΩÅ</code> - Full Width Latin lower case A<br>\n<code>–∞</code> - Cyrillic lower case A</p>\n\n<p>The generic term for this is \"homoglyphs\": different unicode characters that look the same. Typically hard to get <em>three</em> that are utterly indistinguishable, but in some cases you can get lucky. A, Œë, –ê, and ·é™ would work better (Latin-A, <a href=\"https://en.wikipedia.org/wiki/Alpha\" rel=\"noreferrer\">Greek Alpha</a>, <a href=\"https://en.wikipedia.org/wiki/A_(Cyrillic)\" rel=\"noreferrer\">Cyrillic-A</a>, and <a href=\"https://en.wiktionary.org/wiki/%E1%8E%AA#Cherokee\" rel=\"noreferrer\">Cherokee-A</a> respectively; unfortunately the Greek and Cherokee lower-case letters are too different from the Latin <code>a</code>: <code>Œ±</code>,<code>Í≠∫</code>, and so doesn't help with the above snippet).</p>\n\n<p>There's an entire class of Homoglyph Attacks out there, most commonly in fake domain names (eg. <code>wikipedi–∞.org</code> (Cyrillic) vs <code>wikipedia.org</code> (Latin)), but it can show up in code as well; typically referred to as being underhanded (as mentioned in a comment, <a href=\"https://codegolf.stackexchange.com/questions/tagged/underhanded\">[underhanded]</a> questions are now off-topic on <a href=\"https://codegolf.stackexchange.com/\">PPCG</a>, but used to be a type of challenge where these sorts of things would show up).  I used <a href=\"https://www.irongeek.com/homoglyph-attack-generator.php\" rel=\"noreferrer\">this website</a> to find the homoglyphs used for this answer.</p>\n"},{"score":14,"body":"<p>This one uses the defineProperty with a nice side-effect causing global variable!</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var _a = 1\r\n\r\nObject.defineProperty(this, \"a\", {\r\n  \"get\": () =&gt; {\r\n    return _a++;\r\n  },\r\n  configurable: true\r\n});\r\n\r\nconsole.log(a)\r\nconsole.log(a)\r\nconsole.log(a)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":211,"body":"<p>When you can't do anything without regular expressions:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a = {\r\n  r: /\\d/g, \r\n  valueOf: function(){\r\n    return this.r.exec(123)[0]\r\n  }\r\n}\r\n\r\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n    console.log(\"!\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>It works because of custom <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\" rel=\"noreferrer\"><code>valueOf</code></a> method that is called when Object compared with primitive (such as Number). Main trick is that <code>a.valueOf</code> returns new value every time because it's calling <code>exec</code> on regular expression with <code>g</code> flag, which causing updating <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex\" rel=\"noreferrer\"><code>lastIndex</code></a> of that regular expression every time match is found. So first time <code>this.r.lastIndex == 0</code>, it matches <code>1</code> and updates <code>lastIndex</code>: <code>this.r.lastIndex == 1</code>, so next time regex will match <code>2</code> and so on.</p>\n"},{"score":27,"body":"<p>Actually the answer to the first part of the question is \"Yes\" in every programming language. For example, this is in the case of C/C++:</p>\n\n<pre><code>#define a   (b++)\nint b = 1;\nif (a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) {\n    std::cout &lt;&lt; \"Yes, it's possible!\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"it's impossible!\" &lt;&lt; std::endl;\n}\n</code></pre>\n"},{"score":41,"body":"<p>Here's another variation, using an array to pop off whatever values you want.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const a = {\r\n  n: [3,2,1],\r\n  toString: function () {\r\n    return a.n.pop();\r\n  }\r\n}\r\n\r\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('Yes');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":31,"body":"<p>Okay, another hack with generators:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const value = function* () {\r\n  let i = 0;\r\n  while(true) yield ++i;\r\n}();\r\n\r\nObject.defineProperty(this, 'a', {\r\n  get() {\r\n    return value.next().value;\r\n  }\r\n});\r\n\r\nif (a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3) {\r\n  console.log('yo!');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":68,"body":"<p>Honestly though, whether there is a way for it to evaluate to true or not (and as others have shown, there are multiple ways), the answer I'd be looking for, speaking as someone who has conducted hundreds of interviews, would be something along the lines of:</p>\n\n<p>\"Well, maybe yes under some weird set of circumstances that aren't immediately obvious to me... but if I encountered this in real code then I would use common debugging techniques to figure out how and why it was doing what it was doing and then immediately refactor the code to avoid that situation... but more importantly: I would absolutely NEVER write that code in the first place because that is the very definition of convoluted code, and I strive to never write convoluted code\".</p>\n\n<p>I guess some interviewers would take offense to having what is obviously meant to be a very tricky question called out, but I don't mind developers who have an opinion, especially when they can back it up with reasoned thought and can dovetail my question into a meaningful statement about themselves.</p>\n"},{"score":190,"body":"<p>This is possible in case of variable <code>a</code> being accessed by, say 2 web workers through a SharedArrayBuffer as well as some main script. The possibility is low, but it is possible that when the code is compiled to machine code, the web workers update the variable <code>a</code> just in time so the conditions <code>a==1</code>, <code>a==2</code> and <code>a==3</code> are satisfied.</p>\n\n<p>This can be an example of race condition in multi-threaded environment provided by web workers and SharedArrayBuffer in JavaScript.</p>\n\n<p>Here is the basic implementation of above:</p>\n\n<p>main.js</p>\n\n<pre><code>// Main Thread\n\nconst worker = new Worker('worker.js')\nconst modifiers = [new Worker('modifier.js'), new Worker('modifier.js')] // Let's use 2 workers\nconst sab = new SharedArrayBuffer(1)\n\nmodifiers.forEach(m =&gt; m.postMessage(sab))\nworker.postMessage(sab)\n</code></pre>\n\n<p>worker.js</p>\n\n<pre><code>let array\n\nObject.defineProperty(self, 'a', {\n  get() {\n    return array[0]\n  }\n});\n\naddEventListener('message', ({data}) =&gt; {\n    array = new Uint8Array(data)\n    let count = 0\n    do {\n        var res = a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3\n        ++count\n    } while(res == false) // just for clarity. !res is fine\n    console.log(`It happened after ${count} iterations`)\n    console.log('You should\\'ve never seen this')\n})\n</code></pre>\n\n<p>modifier.js</p>\n\n<pre><code>addEventListener('message' , ({data}) =&gt; {\n    setInterval( () =&gt; {\n        new Uint8Array(data)[0] = Math.floor(Math.random()*3) + 1\n    })\n})\n</code></pre>\n\n<p>On my MacBook Air, it happens after around 10 billion iterations on the first attempt:</p>\n\n<p><a href=\"https://i.stack.imgur.com/wjNp9.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/wjNp9.png\" alt=\"enter image description here\"></a></p>\n\n<p>Second attempt:</p>\n\n<p><a href=\"https://i.stack.imgur.com/wFrAt.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/wFrAt.png\" alt=\"enter image description here\"></a></p>\n\n<p>As I said, the chances will be low, but given enough time, it'll hit the condition.</p>\n\n<p>Tip: If it takes too long on your system. Try only <code>a == 1 &amp;&amp; a == 2</code> and change <code>Math.random()*3</code> to <code>Math.random()*2</code>. Adding more and more to list drops the chance of hitting.</p>\n"},{"score":97,"body":"<h1>JavaScript</h1>\n\n<h2>a == a +1</h2>\n\n<p>In JavaScript, there are no <a href=\"https://stackoverflow.com/a/33774009/6419007\">integers</a> but only <code>Number</code>s, which are implemented as double precision floating point numbers.</p>\n\n<p>It means that if a Number <code>a</code> is large enough, it can be considered equal to three consecutive integers:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>a = 100000000000000000\r\nif (a == a+1 &amp;&amp; a == a+2 &amp;&amp; a == a+3){\r\n  console.log(\"Precision loss!\");\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>True, it's not exactly what the interviewer asked (it doesn't work with <code>a=0</code>), but it doesn't involve any trick with hidden functions or operator overloading.</p>\n\n<h1>Other languages</h1>\n\n<p>For reference, there are <code>a==1 &amp;&amp; a==2 &amp;&amp; a==3</code> solutions in Ruby and Python. With a slight modification, it's also possible in Java.</p>\n\n<h2>Ruby</h2>\n\n<p>With a custom <code>==</code>:</p>\n\n<pre><code>class A\n  def ==(o)\n    true\n  end\nend\n\na = A.new\n\nif a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3\n  puts \"Don't do this!\"\nend\n</code></pre>\n\n<p>Or an increasing <code>a</code>:</p>\n\n<pre><code>def a\n  @a ||= 0\n  @a += 1\nend\n\nif a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3\n  puts \"Don't do this!\"\nend\n</code></pre>\n\n<h2>Python</h2>\n\n<pre><code>class A:\n    def __eq__(self, who_cares):\n        return True\na = A()\n\nif a == 1 and a == 2 and a == 3:\n    print(\"Don't do that!\")\n</code></pre>\n\n<h2>Java</h2>\n\n<p>It's possible to modify Java <a href=\"http://code4reference.com/2012/08/swap-integers-value-java/\" rel=\"noreferrer\"><code>Integer</code> cache</a>:</p>\n\n<pre><code>package stackoverflow;\n\nimport java.lang.reflect.Field;\n\npublic class IntegerMess\n{\n    public static void main(String[] args) throws Exception {\n        Field valueField = Integer.class.getDeclaredField(\"value\");\n        valueField.setAccessible(true);\n        valueField.setInt(1, valueField.getInt(42));\n        valueField.setInt(2, valueField.getInt(42));\n        valueField.setInt(3, valueField.getInt(42));\n        valueField.setAccessible(false);\n\n        Integer a = 42;\n\n        if (a.equals(1) &amp;&amp; a.equals(2) &amp;&amp; a.equals(3)) {\n            System.out.println(\"Bad idea.\");\n        }\n    }\n}\n</code></pre>\n"},{"score":527,"body":"<p>Example without getters or valueOf:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>a = [1,2,3];\r\na.join = a.shift;\r\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This works because <code>==</code> invokes <code>toString</code> which calls <code>.join</code> for Arrays.</p>\n\n<p>Another solution, using <code>Symbol.toPrimitive</code> which is an ES6 equivalent of <code>toString/valueOf</code>: </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let i = 0;\r\nlet a = { [Symbol.toPrimitive]: () =&gt; ++i };\r\n\r\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":43,"body":"<p>If you ever get such an interview question (or notice some equally unexpected behavior in your code) think about what kind of things could possibly cause a behavior that looks impossible at first glance:</p>\n\n<ol>\n<li><p><strong>Encoding</strong>: In this case the variable you are looking at is not the one you think it is. This can happen if you intentionally mess around with Unicode using <a href=\"https://en.wikipedia.org/wiki/Homoglyph#Unicode_homoglyphs\" rel=\"noreferrer\">homoglyphs</a> or <a href=\"https://stackoverflow.com/a/48274520/40347\">space characters</a> to make the name of a variable look like another one, but encoding issues can also be introduced accidentally, e.g. when copying &amp; pasting code from the Web that contains unexpected Unicode code points (e.g. because a content management system  did some \"auto-formatting\" such as replacing <code>fl</code> with Unicode 'LATIN SMALL LIGATURE FL' (U+FB02)).</p></li>\n<li><p><strong>Race conditions</strong>: A <a href=\"https://stackoverflow.com/a/48295891/40347\">race-condition</a> might occur, i.e. a situation where code is not executing in the sequence expected by the developer. Race conditions often happen in multi-threaded code, but multiple threads are not a requirement for race conditions to be possible ‚Äì asynchronicity is sufficient (and don't get confused, <a href=\"https://stackoverflow.com/a/8963287/40347\">async does not mean multiple threads are used under the hood</a>). </p>\n\n<p>Note that therefore JavaScript is also not free from race conditions just because it is single-threaded. See <a href=\"https://medium.com/@slavik57/async-race-conditions-in-javascript-526f6ed80665\" rel=\"noreferrer\">here</a> for a simple single-threaded ‚Äì but async ‚Äì example. In the context of an single statement the race condition however would be rather hard to hit in JavaScript.</p>\n\n<p>JavaScript with web workers is a bit different, as you can have multiple threads. @mehulmpt has shown us a great <a href=\"https://stackoverflow.com/a/48295891/40347\">proof-of-concept using web workers</a>.</p></li>\n<li><p><strong>Side-effects</strong>:  A side-effect of the equality comparison operation (which doesn't have to be as obvious as in the examples here, often side-effects are very subtle).  </p></li>\n</ol>\n\n<p>These kind of issues can appear in many programming languages, not only JavaScript, so we aren't seeing one of the classical <a href=\"https://github.com/denysdovhan/wtfjs\" rel=\"noreferrer\">JavaScript WTFs</a> here<sup>1</sup>. </p>\n\n<p>Of course, the interview question and the samples here all look very contrived. But they are a good reminder that:</p>\n\n<ul>\n<li>Side-effects can get really nasty and that a well-designed program should be free from unwanted side-effects.</li>\n<li>Multi-threading and mutable state can be problematic.</li>\n<li>Not doing character encoding and string processing right can lead to nasty bugs.</li>\n</ul>\n\n<p><sub><sup>1</sup> For example, you can find an example in a totally different programming language (C#) exhibiting a side-effect (an obvious one) <a href=\"https://gist.github.com/dirvo/bd2aa2242da0fd092239e8b117e9f1cb\" rel=\"noreferrer\">here</a>.</sub></p>\n"},{"score":26,"body":"<p>Same, but different, but still same (can be \"tested\" multiple times):</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const a = { valueOf: () =&gt; this.n = (this.n || 0) % 3 + 1}\r\n    \r\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('Hello World!');\r\n}\r\n\r\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('Hello World!');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>My idea started from how Number object type equation works.</p>\n"},{"score":25,"body":"<p>An ECMAScript&nbsp;6 answer that makes use of Symbols:</p>\n\n<pre><code>const a = {value: 1};\na[Symbol.toPrimitive] = function() { return this.value++ };\nconsole.log((a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3));\n</code></pre>\n\n<p>Due to <code>==</code> usage, JavaScript is supposed to coerce <code>a</code> into something close to the second operand (<code>1</code>, <code>2</code>, <code>3</code> in this case). But before JavaScript tries to figure coercing on its own, it tries to call <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\" rel=\"noreferrer\"><code>Symbol.toPrimitive</code></a>. If you provide <code>Symbol.toPrimitive</code> JavaScript would use the value your function returns. If not, JavaScript would call <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\" rel=\"noreferrer\"><code>valueOf</code></a>.</p>\n"},{"score":81,"body":"<p>This is an inverted version of <a href=\"https://stackoverflow.com/a/48274520/87015\">@Jeff's answer</a>* where a hidden character (U+115F, U+1160 or U+3164) is used to create variables that look like <code>1</code>, <code>2</code> and <code>3</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var  a = 1;\r\nvar Ôæ†1 = a;\r\nvar Ôæ†2 = a;\r\nvar Ôæ†3 = a;\r\nconsole.log( a ==Ôæ†1 &amp;&amp; a ==Ôæ†2 &amp;&amp; a ==Ôæ†3 );</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>* That answer can be simplified by using zero width non-joiner (U+200C) and zero width joiner (U+200D). Both of these characters are allowed inside identifiers but not at the beginning:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a = 1;\r\nvar a‚Äå = 2;\r\nvar a‚Äç = 3;\r\nconsole.log(a == 1 &amp;&amp; a‚Äå == 2 &amp;&amp; a‚Äç == 3);\r\n\r\n/****\r\nvar a = 1;\r\nvar a\\u200c = 2;\r\nvar a\\u200d = 3;\r\nconsole.log(a == 1 &amp;&amp; a\\u200c == 2 &amp;&amp; a\\u200d == 3);\r\n****/</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Other tricks are possible using the same idea e.g. by using Unicode variation selectors to create variables that look exactly alike (<code>aÔ∏Ä = 1; aÔ∏Å = 2; aÔ∏Ä == 1 &amp;&amp; aÔ∏Å == 2; // true</code>).</p>\n"},{"score":29,"body":"<p>Using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" rel=\"noreferrer\">Proxies</a>:</p>\n\n<pre><code>var a = new Proxy({ i: 0 }, {\n    get: (target, name) =&gt; name === Symbol.toPrimitive ? () =&gt; ++target.i : target[name],\n});\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3);\n</code></pre>\n\n<p>Proxies basically pretend to be a target object (the first parameter), but intercept operations on the target object (in this case the \"get property\" operation) so that there is an opportunity to do something other than the default object behavior. In this case the \"get property\" action is called on <code>a</code> when <code>==</code> coerces its type in order to compare it to each number. This happens:</p>\n\n<ol>\n<li>We create a target object, <code>{ i: 0 }</code>, where the <code>i</code> property is our counter</li>\n<li>We create a Proxy for the target object and assign it to <code>a</code></li>\n<li>For each <code>a ==</code> comparison, <code>a</code>'s type is coerced to a primitive value</li>\n<li>This type coercion results in calling <code>a[Symbol.toPrimitive]()</code> internally</li>\n<li>The Proxy intercepts getting the <code>a[Symbol.toPrimitive]</code> function using the \"get handler\"</li>\n<li>The Proxy's \"get handler\" checks that the property being gotten is <code>Symbol.toPrimitive</code>, in which case it increments and then returns the counter from the target object: <code>++target.i</code>. If a different property is being retrieved, we just fall back to returning the default property value, <code>target[name]</code></li>\n</ol>\n\n<p>So:</p>\n\n<pre><code>var a = ...; // a.valueOf == target.i == 0\na == 1 &amp;&amp; // a == ++target.i == 1\na == 2 &amp;&amp; // a == ++target.i == 2\na == 3    // a == ++target.i == 3\n</code></pre>\n\n<p>As with most of the other answers, this only works with a loose equality check (<code>==</code>), because strict equality checks (<code>===</code>) do not do type coercion that the Proxy can intercept.</p>\n"},{"score":111,"body":"<h2>Yes, it is possible! üòé</h2>\n\n<h2>¬ª JavaScript</h2>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>if‚Äå=()=&gt;!0;\r\nvar a = 9;\r\n\r\nif‚Äå(a==1 &amp;&amp; a== 2 &amp;&amp; a==3)\r\n{\r\n    document.write(\"&lt;h1&gt;Yes, it is possible!üòé&lt;/h1&gt;\")\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The above code is a short version (thanks to  @Forivin for its note in comments) and the following code is original:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a = 9;\r\n\r\nif‚Äå(a==1 &amp;&amp; a== 2 &amp;&amp; a==3)\r\n{\r\n    //console.log(\"Yes, it is possible!üòé\")\r\n    document.write(\"&lt;h1&gt;Yes, it is possible!üòé&lt;/h1&gt;\")\r\n}\r\n\r\n//--------------------------------------------\r\n\r\nfunction if‚Äå(){return true;}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<blockquote>\n  <p>If you just see top side of my code and run it you say WOW, how?</p>\n  \n  <p>So I think it is enough to say <em>Yes, it is possible</em> to someone that said to\n  you: <em>Nothing is impossible</em></p>\n  \n  <p>Trick: I used a hidden character after <code>if</code> to make a function that its name is similar to <code>if</code>. In JavaScript we can not override keywords so I forced to use this way. It is a fake <code>if</code>, but it works for you in this case!</p>\n</blockquote>\n\n<hr>\n\n<h2>¬ª <strong>C#</strong></h2>\n\n<p>Also I wrote a C# version (<em>with increase property value technic</em>):</p>\n\n<pre><code>static int _a;\npublic static int a =&gt; ++_a;\n\npublic static void Main()\n{\n    if(a==1 &amp;&amp; a==2 &amp;&amp; a==3)\n    {\n        Console.WriteLine(\"Yes, it is possible!üòé\");\n    }\n}\n</code></pre>\n\n<p><strong><a href=\"https://dotnetfiddle.net/twNcDM\" rel=\"noreferrer\">Live Demo</a></strong></p>\n"},{"score":24,"body":"<p>I think this is the minimal code to implement it:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>i=0,a={valueOf:()=&gt;++i}\r\n\r\nif (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\r\n  console.log('Mind === Blown');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Creating a dummy object with a custom <code>valueOf</code> that increments a global variable <code>i</code> on each call. 23 characters!</p>\n"},{"score":3,"body":"<p>By overriding <code>valueOf</code> in a class declaration, it can be done:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>class Thing {\n    constructor() {\n        this.value = 1;\n    }\n\n    valueOf() {\n        return this.value++;\n    }\n}\n\nconst a = new Thing();\n\nif(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {\n    console.log(a);\n}\n</code></pre>\n\n<p>What happens is that <code>valueOf</code> is called in each comparison operator.  On the first one, <code>a</code> will equal <code>1</code>, on the second, <code>a</code> will equal <code>2</code>, and so on and so forth, because each time <code>valueOf</code> is called, the value of <code>a</code> is incremented.</p>\n\n<p>Therefore the console.log will fire and output (in my terminal anyways) <code>Thing: { value: 4}</code>, indicating the conditional was true.</p>\n"}],"score":2527}